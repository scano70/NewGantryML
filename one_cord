import pandas as pd
import math
import numpy as np
import time
import os, cv2
import keras
import tensorflow
from tensorflow.python.keras import datasets, layers, models
from keras.models import Sequential
from keras.layers import Dense, Activation
from keras.utils import np_utils
from keras import backend as K
from sklearn.model_selection import train_test_split
from keras.layers import *
from keras.models import Model


imgPATH = '/home/samcano/pyfiles/250x250/line_imgs/'
csvPATH = '/home/samcano/pyfiles/250x250/250x250_labels.csv'
data = pd.read_csv(csvPATH, skipinitialspace=True)
coord1 = [0] * 508
coord2 = [0] * 508
imlist = [0] * 508


def makeDF():

    listing = os.listdir(imgPATH)
    imarray = 0
    for i in range(508):
        b = data['External ID'][i] + ".png"
        img_location = imgPATH + b
        for img in listing:
            if(img == b):
                imarray = cv2.imread(img_location)
                break
        imlist[i] = imarray
        data['External ID'][i] = b
    data['Image Array'] = imlist
    return data, imlist

def handleCSV():
    #parse csv for x and y values
    for i in range(508):
        data2 = data['Label'][i].split(':')
        coord1[i] = [0.0 ,0.0]
        coord2[i] = [0.0 ,0.0]
        x1 = data2[3].split(",")
        y1 = data2[4].split("}")
        x2 = data2[7].split(",")
        y2 = data2[8].split("}")

        #orient labels so origin is bottom left corner
        x1= float(x1[0])
        y1= -1 * (float(y1[0]) - 250.0)
        x2= float(x2[0])
        y2= -1 * (float(y2[0]) - 250.0)

        #load and normalize
        coord1[i] = [x1/250.0, y1/250.0]
        coord2[i] = [x2/250.0, y2/250.0]
    data["Label"] = coord1
    data["Label_2"] = coord2
    return data

def train():
    print "HERE"
    input_imgs = np.reshape(imlist, (508,250,250,3))
    input_shape = input_imgs[0].shape
    print input_imgs.shape
    x, y = input_imgs, coord1
    X_train, X_test, y_train, y_test = train_test_split(x,y, test_size=0.2)
    X_train = np.array(X_train)
    y_train = np.array(y_train)
    X_test = np.array(X_test)
    y_test = np.array(y_test)

    model1 = models.Sequential()
    model1.add(layers.Conv2D(32, (3, 3), activation='relu', input_shape=input_shape))
    model1.add(layers.MaxPooling2D((2, 2)))
    model1.add(layers.Conv2D(64, (3, 3), activation='relu'))
    model1.add(layers.MaxPooling2D((2, 2)))
    model1.add(layers.Dropout(0.5))
    model1.add(layers.Dense(128, activation='relu'))
    model1.add(layers.Flatten())
    model1.add(layers.Dense(64, activation='relu'))
    model1.add(layers.Dropout(0.5))
    model1.add(layers.Dense(2, activation='relu'))
    model1.compile(optimizer='adam', loss='mse',metrics=['accuracy', 'mse'])
    model1.summary()
    model1.get_config()
    model1.layers[0].get_config()
    model1.layers[0].input_shape
    model1.layers[0].output_shape
    model1.layers[0].get_weights()
    np.shape(model1.layers[0].get_weights()[0])
    model1.layers[0].trainable

   #fit the model
    hist = model1.fit(X_train, y_train, batch_size=16, epochs=100, verbose=1, validation_data=(X_test, y_test))

    y_pred = model1.predict(X_test,batch_size =16)

    return 0


'''
    model2 = models.Sequential()
    model2.add(layers.Conv2D(32, (3, 3), activation='relu', input_shape=input_shape))
    model2.add(layers.MaxPooling2D((2, 2)))
    model2.add(layers.Conv2D(64, (3, 3), activation='relu'))
    model2.add(layers.MaxPooling2D((2, 2)))
    model2.add(layers.Dropout(0.5))
    model2.add(layers.Dense(128, activation='relu'))
    model2.add(layers.Dense(64, activation='relu'))
    model2.add(layers.Dropout(0.5))

    mergedOut = Add()([model1.output,model2.output])
    mergedOut = Flatten()(mergedOut)
    mergedOut = Dense(256, activation='relu')(mergedOut)
    mergedOut = Dropout(.5)(mergedOut)
    mergedOut = Dense(128, activation='relu')(mergedOut)
    mergedOut = Dropout(.35)(mergedOut)

    newModel = Model([model1.input,model2.input], mergedOut)
'''

if __name__ == '__main__':
    makeDF()
    handleCSV()
    train()
